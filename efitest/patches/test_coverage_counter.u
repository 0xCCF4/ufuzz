.org 0x7c00

let [adr_stg_trace_result] := 0xba00
let [adr_ucode_rdrand] := 0x0428

let [adr_stg_r10] := 0xba40
let [adr_stg_r11] := 0xba80
let [adr_stg_r12] := 0xbac0
let [adr_stg_r13] := 0xbb00

let [in_hook_index] := r10
let [in_ucode_exit] := r11
let [frontend_prev] := r12
let [tmp] := r13

# -------------- ENTRY

STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r10], , r10) !m2 # save original value of r10, r11
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r11], , r11) !m2

[in_ucode_exit] := ZEROEXT_DSZ32(<exit>)   # ucode exit handler address
[in_hook_index] := ZEROEXT_DSZ32(0x00)    # hook index

NOP SEQW GOTO <handler>

# --------------

# NOTICE: assume no one else uses [0xba00, 0xbb00] in the staging buffer

<handler>
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r12], , r12) !m2 # save original value of r12, 13
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r13], , r13) !m2

# pause frontend
[tmp]:= ZEROEXT_DSZ32(0x00000000)
[frontend_prev] := MOVEFROMCREG_DSZ64( , 0x38c)
MOVETOCREG_DSZ64([tmp], 0x38c) !m2

# def ucode_sequencer_write(SELECTOR, ADDR, VAL):
#     CRBUS[0x6a1] = 0x30000 | (SELECTOR << 8)
#     CRBUS[0x6a0] = ADDR
#     CRBUS[0x6a4] = VAL & 0xffffffff
#     CRBUS[0x6a5] = VAL >> 32
#     CRBUS[0x6a1] = 0

[tmp]:= ZEROEXT_DSZ32(0x00000303)  # select match patch mem array
[tmp]:= SHL_DSZ32(r13, 0x00000008) # .

MOVETOCREG_DSZ64([tmp], 0x6a1) !m2            # CRBUS[0x6a1] = 0x30000 | (SELECTOR << 8)
MOVETOCREG_DSZ64([in_hook_index], 0x6a0) !m2  # CRBUS[0x6a0] = ADDR = [in_hook_index]

[tmp]:= ZEROEXT_DSZ32(0x0)

MOVETOCREG_DSZ64([tmp], 0x6a4) !m2  # CRBUS[0x6a4] = VAL_low = 0
MOVETOCREG_DSZ64([tmp], 0x6a5) !m2  # CRBUS[0x6a4] = VAL_high = 0

MOVETOCREG_DSZ64(r10, 0x6a1) !m2  # CRBUS[0x6a1] = 0 : WRITE

# restore frontend
MOVETOCREG_DSZ64([frontend_prev], 0x38c) !m2

# hook is now disabled

# increment tracing location
[tmp] := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_trace_result]) !m2
[tmp] := ADD_DSZ64([tmp], 0x1)
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_trace_result], , [tmp]) !m2

# write clock value to tracing location
# [tmp]:= MOVEFROMCREG_DSZ64( , 0x2d7) !m1,m2
# STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_trace_result], , [tmp]) !m2

# restore registers
r10 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r10]) !m2
r12 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r12]) !m2
r13 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r13]) !m2

UJMP(,[in_ucode_exit]) SEQW NOP


# --------------- EXIT

<exit>

# restore r11
r11 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r11]) !m2

# exit and goto original instruction
NOP SEQW GOTO 0x0428 # rdrand

# ---------------