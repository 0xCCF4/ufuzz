# copy all values from the jump table to the coverage table

# offset
tmp0 := ZEROEXT_DSZ32(0x0000)

# base addresses
tmp10 := ZEROEXT_DSZ32([address_jump_table_base])
tmp11 := ZEROEXT_DSZ32([address_coverage_table_base])

<selfcheck_loop>
# copy value
tmp1 := LDPPHYS_DSZ16_ASZ32_SC1(tmp0, tmp10)
STADPPHYS_DSZ16_ASZ32_SC1(tmp11, tmp0, tmp1)

# increase offset
tmp0 := ADD_DSZ32(tmp0, 0x0002)

tmp2 := SUB_DSZ32(tmp0, [table_size])
UJMPCC_DIRECT_NOTTAKEN_CONDNZ(tmp2, <selfcheck_loop>)

rbx := ADD_DSZ32(0x0000, tmp0)
rax := ZEROEXT_DSZ32(0x00abc)

NOPB
NOP SEQW LFNCEWAIT, UEND0
NOPB

# ---- INTERFACE -----
#
# unsafe fn selfcheck(interface: &mut ComInterface) -> bool {
#     for i in 0..interface.description().max_number_of_hooks {
#         interface.write_jump_table(i, i as u16);
#     }
#     // check
#     interface.reset_coverage();
#     for i in 0..interface.description().max_number_of_hooks {
#         let val = interface.read_coverage_table(i);
#         if val != 0 {
#             println!("Coverage table not zeroed at index {}", i);
#             return false;
#         }
#     }
#
#     let result = call_custom_ucode_function(coverage_collector::LABEL_SELFCHECK_FUNC, [0, 0, 0]);
#     if result.rax != 0xABC || result.rbx >> 1 != interface.description().max_number_of_hooks {
#         println!("Selfcheck invoke failed: {:x?}", result);
#         return false;
#     }
#
#     for i in 0..interface.description().max_number_of_hooks {
#         let val = interface.read_coverage_table(i);
#         if val != i as u16 {
#             println!("Selfcheck mismatch [{i:x}] {val:x}");
#             return false;
#         }
#     }
#
#     true
# }