.org 0x7c00

<exit>
# will be overriden dynamically
NOP SEQW SYNCFULL, UEND0
NOP
NOP



include <gen/interface_definition.up>
include <variables.up>

<selfcheck_func>
include <selfcheck.up>

<func_hook>
include <sys/func_hook.up>

<func_ldat_read_hooks>
include <sys/func_ldat_read_hooks.up>

<func_ldat_read>
include <sys/func_ldat_read.up>



<handler>
# save remaining context
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r11], , r11) !m2 # save original value of r11
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r12], , r12) !m2 # save original value of r12
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r13], , r13) !m2 # save original value of r13

#                                                          |- tmp -|
func record_coverage_and_jumpback_address([in_hook_offset], r11, r12, r13)
# <- jump back address now in r13

# disables hook
r11 := ZEROEXT_DSZ64(0x0)
func lib/pause_frontend(r12, r11)
func lib/ldat_write([in_hook_offset], r11, r11, 3) # zeros hook entry at offset [in_hook_offset]
func lib/resume_frontend(r12)

func lib/compute_seqw_jump(r10, r13, r11, r12)
# <- seqw now in r10

rax := ZEROEXT_DSZ32(r10)

func write_exit_handler(r10, r11, r12, r13)

# restore context
r10 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r10]) !m2
r11 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r11]) !m2
r12 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r12]) !m2
r13 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r13]) !m2

NOP SEQW GOTO <exit>

include <gen/entries.up>





<crc_calc_func>
# IN: tmp0 value 16bit
# OUT: rax parity

func lib/compute_seqw_jump(rax, tmp0, tmp1, tmp2)

NOP SEQW LFNCEWAIT, UEND0



<write_seqw_func>
# IN: tmp0 value 32bit

func write_exit_handler(tmp0, tmp1, tmp2, tmp3)

NOP SEQW LFNCEWAIT, UEND0

