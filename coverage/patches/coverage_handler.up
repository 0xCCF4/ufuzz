STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r12], , r12) !m2 # save original value of r12, 13
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r13], , r13) !m2

# pause frontend
[tmp]:= ZEROEXT_DSZ32(0x00000000)
[frontend_prev] := MOVEFROMCREG_DSZ64( , 0x38c)
MOVETOCREG_DSZ64([tmp], 0x38c) !m2

# def ucode_sequencer_write(SELECTOR, ADDR, VAL):
#     CRBUS[0x6a1] = 0x30000 | (SELECTOR << 8)
#     CRBUS[0x6a0] = ADDR
#     CRBUS[0x6a4] = VAL & 0xffffffff
#     CRBUS[0x6a5] = VAL >> 32
#     CRBUS[0x6a1] = 0

[tmp]:= ZEROEXT_DSZ32(0x00000303)  # select match patch mem array
[tmp]:= SHL_DSZ32(r13, 0x00000008) # .

MOVETOCREG_DSZ64([tmp], 0x6a1) !m2            # CRBUS[0x6a1] = 0x30000 | (SELECTOR << 8)
MOVETOCREG_DSZ64([in_hook_index], 0x6a0) !m2  # CRBUS[0x6a0] = ADDR = [in_hook_index]

[tmp]:= ZEROEXT_DSZ32(0x0)

MOVETOCREG_DSZ64([tmp], 0x6a4) !m2  # CRBUS[0x6a4] = VAL_low = 0
MOVETOCREG_DSZ64([tmp], 0x6a5) !m2  # CRBUS[0x6a4] = VAL_high = 0

MOVETOCREG_DSZ64(r10, 0x6a1) !m2  # CRBUS[0x6a1] = 0 : WRITE

# restore frontend
MOVETOCREG_DSZ64([frontend_prev], 0x38c) !m2

# hook is now disabled

# increment tracing location
[tmp] := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_trace_result]) !m2
[tmp] := ADD_DSZ64([tmp], 0x1)
STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_trace_result], , [tmp]) !m2

# write clock value to tracing location
# [tmp]:= MOVEFROMCREG_DSZ64( , 0x2d7) !m1,m2
# STADSTGBUF_DSZ64_ASZ16_SC1([adr_stg_trace_result], , [tmp]) !m2

# restore registers
r10 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r10]) !m2
r12 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r12]) !m2
r13 := LDSTGBUF_DSZ64_ASZ16_SC1([adr_stg_r13]) !m2

UJMP(,[in_ucode_exit]) SEQW NOP
