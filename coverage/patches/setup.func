# ARG0: {n} - number of hooks to patch
# ARG1: {tmp_counter} - temporary counter
# ARG2: {tmp_frontend_prev} - temporary frontend value
# ARG3: {0} - arbitrary temporary value
# ARG4: {1} - arbitrary temporary value
# ARG5: {2} - arbitrary temporary value
# ARG6: {3} - arbitrary temporary value
# ARG7: {4} - arbitrary temporary value

# Workings:
# 1. Zero all hooks
# 2. Patch exit hooks with new return values
# 3. Enable hooks until index n-1


# todo: it now works, but combine all 3 loops into one for better performance

NOPB
NOP SEQW GOTO <setup>

<ldat_write>
func lib/ldat_write({0}, {2}, {1}, {4})
NOP SEQW URET0

<setup>

# Initialization
{2} := ZEROEXT_DSZ64(0x0)


# Deactivate frontend
# -----------------------------
func lib/pause_frontend({tmp_frontend_prev}, {2})


# 1. Zero all hooks
# -----------------------------
{tmp_counter} := ZEROEXT_DSZ64(0x0)
<setup_zero_loop>
# if index == table_length
func lib/jump_if_equal({tmp_counter}, [table_length], {0}, 32, <setup_zero_loop_end>)

{0} := SHL_DSZ64({tmp_counter}, 0x1) # in hooks memory, only even addresses writable
#                   addr  value      tmp  HOOKS
{4} := ZEROEXT_DSZ64(0x3) SEQW SAVEUIP0, GOTO <ldat_write>
NOPB

{tmp_counter} := ADD_DSZ64({tmp_counter}, 0x1) SEQW GOTO <setup_zero_loop>
<setup_zero_loop_end>


# 2. Patch exit hooks with new return values
# -------------------------------------------
{tmp_counter} := ZEROEXT_DSZ64(0x0)
<setup_exit_loop>
# if index == n || index == table_length
func lib/jump_if_equal({tmp_counter}, {n}, {0}, 32, <setup_exit_loop_end>)
func lib/jump_if_equal({tmp_counter}, [table_length], {0}, 32, <setup_exit_loop_end>)

# Write replacement triad
{3} := ZEROEXT_DSZ64(0x00)

<setup_replacement_loop>
func lib/jump_if_equal({3}, 0x03, {0}, 32, <setup_replacement_loop_end>)
{0} := SHL_DSZ64({tmp_counter}, [convert_index_to_instruction_table_offset])
{0} := ADD_DSZ64({0}, [address_instruction_table_base])
{1} := SHL_DSZ64({3}, 0x03) # 64bit values
{2} := LDPPHYS_DSZ64_ASZ32_SC1({0}, {1}) # {2} := INSTRUCTION_TABLE[index][offset]
{0} := SHL_DSZ64({tmp_counter}, 0x02) # {0} := index * 4
{0} := ADD_DSZ64({0}, [hook_exit_offset]) # {0} := <hook_exit_00> - 0x7c00 + index * 4
{0} := ADD_DSZ64({0}, {3}) # {0} := <hook_exit_00> - 0x7c00 + index * 4 + triad_offset

{4} := ZEROEXT_DSZ64(0x4) SEQW SAVEUIP0, GOTO <ldat_write>
NOPB

{3} := ADD_DSZ64({3}, 0x1) SEQW GOTO <setup_replacement_loop>
<setup_replacement_loop_end>

{0} := SHL_DSZ64({tmp_counter}, [convert_index_to_instruction_table_offset])
{0} := ADD_DSZ64({0}, 0x18)
{1} := ZEROEXT_DSZ64([address_instruction_table_base])
{2} := LDPPHYS_DSZ64_ASZ32_SC1({0}, {1}) # {2} := INSTRUCTION_TABLE[index][3]

{0} := ADD_DSZ64({tmp_counter}, [hook_exit_offset_in_seqw])
{4} := ZEROEXT_DSZ64(0x2) SEQW SAVEUIP0, GOTO <ldat_write>
NOPB


{tmp_counter} := ADD_DSZ64({tmp_counter}, 0x1) SEQW GOTO <setup_exit_loop>
<setup_exit_loop_end>


# 3. Write new hooks
# ---------------------------
{tmp_counter} := ZEROEXT_DSZ64(0x0)
<setup_hook_loop>
# if index == n || index == table_length
func lib/jump_if_equal({tmp_counter}, {n}, {0}, 32, <setup_hook_loop_end>)
func lib/jump_if_equal({tmp_counter}, [table_length], {0}, 32, <setup_hook_loop_end>)

{0} := SHL_DSZ64({tmp_counter}, 0x01)
{1} := ZEROEXT_DSZ64([address_jump_table_base])
{3} := LDPPHYS_DSZ16_ASZ32_SC1({0}, {1}) # {3} := JUMP_TABLE[index]

{0} := SHL_DSZ64({tmp_counter}, 0x02) # {0} := index * 4
{0} := ADD_DSZ64({0}, [hook_entry_address_offset]) # {0} := HOOK_ENTRY + index * 4
func lib/compute_hook({3}, {0}, {1}, {2})
# <-- {2} is now to value to place inside the hook register

{0} := SHL_DSZ64({tmp_counter}, 0x01) # index * 2
{4} := ZEROEXT_DSZ64(0x3) SEQW SAVEUIP0, GOTO <ldat_write>
NOPB

{tmp_counter} := ADD_DSZ64({tmp_counter}, 0x1) SEQW GOTO <setup_hook_loop>
<setup_hook_loop_end>

# Reactivate frontend
# -----------------------
func lib/resume_frontend({tmp_frontend_prev})
