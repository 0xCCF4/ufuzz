use itertools::Itertools;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    generate_opcode_file("src/opcodes.txt", "src/opcodes.rs");
}

fn generate_opcode_file<A: AsRef<Path>, B: AsRef<Path>>(opcodes: A, target_file: B) {
    let opcode_file = fs::read_to_string(&opcodes).expect("Failed to read opcodes file");
    println!(
        "cargo:rerun-if-changed={}",
        opcodes.as_ref().to_string_lossy()
    );

    let mut result = String::new();
    result.push_str(
        "// This file is automatically generated. It will be overwritten without further notice.",
    );
    result.push('\n');

    let mut already_found_mnemonics = Vec::new();

    let mut definitions = Vec::new();

    for line in opcode_file.lines() {
        if line.trim().is_empty() {
            continue;
        }

        let split = line.split(':').map(|v| v.trim()).collect_vec();
        assert!(
            split.len() == 2 || split.len() == 3,
            "{:?} is not a valid opcode line",
            split
        );

        let (opcode, mnemonic, comment) = (split[0], split[1], split.get(2).cloned());
        let opcode = u16::from_str_radix(opcode, 16).expect("Failed to parse opcode");

        let mnemonic_duped = if already_found_mnemonics.contains(&mnemonic) {
            let count = already_found_mnemonics
                .iter()
                .filter(|&&m| m == mnemonic)
                .count();
            format!("{}_{}", mnemonic, count + 1)
        } else {
            mnemonic.to_string()
        };

        already_found_mnemonics.push(mnemonic);

        //result.push_str(&format!("const OPCODE_{}: u16 = 0x{:03x};\n", mnemonic_duped, opcode));
        definitions.push((mnemonic_duped, opcode, comment));
    }

    let unknown_opcodes = (0..(1 << 13) - 1)
        .filter(|op| !definitions.iter().any(|(_, o, _)| o == op))
        .collect_vec();
    for op in unknown_opcodes {
        definitions.push((
            format!("UNKNOWN_{:x}", op),
            op,
            Some("This operand mnemonic is not known"),
        ));
    }

    result.push_str("use num_derive::FromPrimitive;\n");

    result.push_str(
        "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, FromPrimitive, PartialOrd, Ord)]\n",
    );
    result.push_str("#[allow(non_camel_case_types)]\n");
    result.push_str("pub enum Opcode {\n");
    for (mm, op, comment) in definitions.iter() {
        if let Some(comment) = comment {
            result.push_str(format!("/// {}\n", comment).as_str());
        }
        result.push_str(format!("{mm} = 0x{op:03x},\n").as_str());
    }
    result.push_str("}\n");

    result.push_str("impl Opcode {\n");
    fn impl_prefix_func(
        prefix: &str,
        entries: &[(String, u16, Option<&str>)],
        result: &mut String,
    ) {
        let match_text = entries
            .iter()
            .filter(|(mm, _, _)| mm == prefix || mm.starts_with(format!("{prefix}_").as_str()))
            .map(|(mm, _, _)| format!("Self::{}", mm))
            .collect_vec()
            .join(" | ");
        result.push_str(format!("#[allow(non_snake_case)]\npub const fn is_group_{prefix}(&self) -> bool {{ matches!(self, {match_text}) }}\n").as_str());
    }
    definitions
        .iter()
        .flat_map(|(mm, _, _)| {
            let split = mm.split('_').collect_vec();
            let mut result = Vec::new();
            for end in 0..split.len() {
                result.push(split.iter().take(end).cloned().collect_vec().join("_"));
            }
            result
        })
        .filter(|prefix| !prefix.is_empty())
        .unique()
        .for_each(|prefix| impl_prefix_func(&prefix, &definitions, &mut result));

    // is conditional jump
    let conditional_jumps = definitions.iter().filter(|(mm, _, _)| {
        mm.contains("_NOTTAKEN") || mm.contains("_TAKEN") || mm.contains("TESTUSTATE")
    });
    result.push_str(
        format!(
            "pub const fn is_conditional_jump(&self) -> bool {{ matches!(self, {}) }}\n",
            conditional_jumps
                .map(|(mm, _, _)| format!("Self::{mm}"))
                .join("|")
        )
        .as_str(),
    );

    result.push_str("}\n");

    fs::write(&target_file, result).expect("Failed to write opcode file");
    let _ = Command::new("rustfmt")
        .arg(target_file.as_ref())
        .spawn()
        .map(|mut c| c.wait());
}
