#![cfg_attr(not(feature = "build"), no_std)]

#[cfg(feature = "build")]
use error_chain::error_chain;
#[cfg(feature = "build")]
use std::path::PathBuf;
#[cfg(feature = "build")]
use std::process::Command;
#[cfg(feature = "build")]
use std::{env, fs};
#[cfg(feature = "build")]
use std::io::Read;
#[cfg(feature = "build")]
use std::path::Path;

pub type UcodePatchEntry = [usize; 4];
pub type UcodePatchBlob = [UcodePatchEntry];

pub struct Patch<'a> {
    pub addr: usize,
    pub hook_address: Option<usize>,
    pub hook_entry: Option<usize>,
    pub ucode_patch: &'a UcodePatchBlob,
}

#[cfg(feature = "build")]
error_chain! {
    errors {
        CompilerNotFound {
            description("Compiler not found")
            display("Compiler not found. Path does not exist")
        }
        CompilerInvocationError {
            description("Compiler invocation error")
            display("Compiler invocation error")
        }
        CompilationFailed(exit_code: i32) {
            description("Compiler invocation error")
            display("Compiler invocation error. Exit code: {}", exit_code)
        }
        SourceFileDoesNotExist(path: PathBuf) {
            description("Source file does not exist")
            display("Source file {:?} does not exist", path)
        }
    }

    skip_msg_variant
}

#[cfg(feature = "build")]
pub struct UcodeCompiler {
    compiler_path: PathBuf,
}

#[cfg(feature = "build")]
impl UcodeCompiler {
    pub fn new(path: PathBuf) -> Result<UcodeCompiler> {
        if !path.exists()
            || path
                .extension()
                .map(|v| v.to_string_lossy().to_string())
                .unwrap_or("".to_string())
                != "py"
        {
            return Err(ErrorKind::CompilerNotFound.into());
        }

        Ok(UcodeCompiler {
            compiler_path: path,
        })
    }

    pub fn compile(
        &self,
        cpuid: Option<String>,
        input: &PathBuf,
        output: &PathBuf,
        avoid_unknown_256: bool,
    ) -> Result<()> {
        if !input.exists() {
            return Err(ErrorKind::SourceFileDoesNotExist(input.to_owned()).into());
        }

        let mut command = Command::new("python3");

        match self.compiler_path.to_str() {
            None => return Err(ErrorKind::CompilerNotFound.into()),
            Some(path) => command.arg(path),
        };

        if let Some(cpuid) = cpuid {
            command.arg("--cpuid").arg(cpuid);
        }

        command.arg("-i").arg(input).arg("-o").arg(output);

        if avoid_unknown_256 {
            command.arg("--avoid_unk_256");
        }

        let mut cmd = command.spawn().map_err(|_| ErrorKind::CompilerInvocationError)?;

        let result = cmd.wait().map_err(|_| ErrorKind::CompilerInvocationError)?;

        if let Some(mut stdout) = cmd.stdout {
            let mut output = String::new();
            stdout.read_to_string(&mut output).map_err(|_| ErrorKind::CompilerInvocationError)?;
            println!("{}", output);
        }
        if let Some(mut stderr) = cmd.stderr {
            let mut output = String::new();
            stderr.read_to_string(&mut output).map_err(|_| ErrorKind::CompilerInvocationError)?;
            eprintln!("{}", output);
        }

        if result.success() {
            Ok(())
        } else {
            match result.code() {
                Some(code) => Err(ErrorKind::CompilationFailed(code).into()),
                None => Err(ErrorKind::CompilerInvocationError.into()),
            }
        }
    }
}

#[cfg(feature = "build")]
const AUTOGEN: &'static str = "// AUTOGEN_NOTICE: this file is automatically generated. Do not change stuff. This file will be overriden without further notice.";

#[cfg(feature = "build")]
const AUTOGEN_PREFIX: &'static str = "// AUTOGEN_NOTICE: ";

#[cfg(feature = "build")]
pub fn build_script<P: AsRef<Path>, Q: AsRef<Path>>(patch_source_folder: P, target_rust_folder: Q, allow_unused: bool) {
    if !target_rust_folder.as_ref().exists() {
        fs::create_dir(&target_rust_folder).expect("Failed to create target directory");
    } else {
        for file in target_rust_folder.as_ref().read_dir().expect("Target directory not readable") {
            let file = file.expect("Target file not found").path();
            if file
                .extension()
                .map(|v| v.to_string_lossy().to_string())
                .unwrap_or("".to_string())
                .as_str()
                == "rs"
            {
                if std::fs::read_to_string(&file)
                    .expect("Unable to read target file")
                    .starts_with(AUTOGEN_PREFIX)
                {
                    fs::remove_file(file).expect("Unable to remove target file");
                } else {
                    panic!("Target file {file:?} exists but does not contain AUTOGEN_NOTICE");
                }
            }
        }
    }

    let module_path = target_rust_folder.as_ref().with_extension("rs");
    if module_path.exists() {
        // try to check if AUTOGEN_NOTICE
        let content = std::fs::read_to_string(&module_path).expect("Module file not readable");
        if !content.starts_with(AUTOGEN_PREFIX) {
            panic!("The target module file exists but does not contain AUTOGEN_NOTICE");
        }
    }

    let names = crate::build_script_convert_folder(patch_source_folder, &target_rust_folder, allow_unused);

    let allow_import = allow_unused.then_some("#[allow(unused_imports)]\n").unwrap_or("");

    let content = names.iter().fold(String::new(), |acc, name| {
        acc + &format!("mod {name};\n{allow_import}pub use {name}::PATCH as {name};\n")
    });
    std::fs::write(&module_path,
                   format!("{AUTOGEN}\n\n{content}")
                       .as_str()).expect(format!("Failed to write {module_path:?}").as_str());

    // run rustfmt
    let _ = Command::new("rustfmt")
        .arg(module_path)
        .spawn()
        .expect("rustfmt not found")
        .wait()
        .expect("rustfmt failed");
}

#[cfg(feature = "build")]
pub fn build_script_convert_folder<P: AsRef<Path>, Q: AsRef<Path>>(patch_source_folder: P, target_rust_folder: Q, allow_unused: bool) -> Vec<String> {
    let current_directory =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("Cargo must include Manifest dir"));

    if !current_directory.exists() {
        panic!("CARGO_MANIFEST_DIR directory does not exist");
    }
    if !patch_source_folder.as_ref().exists() {
        panic!("Source folder does not exist");
    }
    if !target_rust_folder.as_ref().exists() {
        panic!("Target folder does not exist");
    }

    println!(
        "cargo::rerun-if-changed={}",
        patch_source_folder.as_ref().to_string_lossy()
    );
    println!(
        "cargo::rerun-if-changed={}/*",
        patch_source_folder.as_ref().to_string_lossy()
    );

    let ucode_compiler = current_directory
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("CustomProcessingUnit")
        .join("uasm-lib")
        .join("uasm.py");

    let compiler = UcodeCompiler::new(ucode_compiler).expect("Ucode compiler not found");

    let mut patch_names = Vec::new();

    for patch in patch_source_folder.as_ref()
        .read_dir()
        .expect("Patches directory not readable")
    {
        let patch = patch.expect("Patch not found").path();

        if patch
            .extension()
            .map(|v| v.to_str().unwrap_or(&""))
            .unwrap_or(&"")
            == "u"
        {
            println!("cargo::rerun-if-changed={}", patch.to_string_lossy());
            println!("Compiling: {:?}", patch);

            let target_file =
                target_rust_folder.as_ref().join(patch.file_name().expect("Patch file name not found"));
            patch_names.push(
                target_file
                    .with_extension("")
                    .file_name()
                    .unwrap()
                    .to_string_lossy()
                    .to_string(),
            );

            compiler
                .compile(None, &patch, &target_file.with_extension("h"), true)
                .expect("Compilation failed");
            transform_patch(
                &target_file.with_extension("h"),
                &target_file.with_extension("rs"),
                allow_unused
            );
            fs::remove_file(&target_file.with_extension("h")).expect("Patch file not removed");
        }
    }

    patch_names
}

#[cfg(feature = "build")]
fn transform_patch<P: AsRef<Path>, Q: AsRef<Path>>(patch: P, target: Q, allow_unused: bool) {
    // Transform the patch file from C-header to rust

    let content = std::fs::read_to_string(patch).expect("Patch file not readable");

    let mut addr = None;
    let mut hook_address = None;
    let mut hook_entry = None;

    let allow_dead = allow_unused.then_some("#[allow(dead_code)]").unwrap_or("");

    let regex_variables =
        regex::Regex::new("unsigned long (addr|hook_address|hook_entry) = (0[xX][0-9a-fA-F]+);")
            .expect("regex compile error");

    for capture in regex_variables.captures_iter(&content) {
        let content = capture
            .get(2)
            .expect("Capture not found")
            .as_str()
            .to_string();
        if let Some(variable) = capture.get(1) {
            match variable.as_str() {
                "addr" => addr = Some(content),
                "hook_address" => hook_address = Some(content),
                "hook_entry" => hook_entry = Some(content),
                _ => unreachable!("Unknown variable"),
            }
        }
    }

    let regex_array = regex::Regex::new("unsigned long ucode_patch\\[]\\[4] = \\{\n(([^}]*[^;])*)")
        .expect("Regex compile error");

    let patch = regex_array
        .captures_iter(&content)
        .into_iter()
        .next()
        .expect("No patch block")
        .get(1)
        .expect("No match")
        .as_str();
    let patch = patch.replace("    {", "    [").replace("},\n", "],\n");
    let patch = &patch[0..patch.len() - 4];
    let length = patch.lines().count() / 2;

    let content = format!(
        "{AUTOGEN}

        use ucode_compiler::{{UcodePatchEntry, Patch}};

        {allow_dead}
        pub const PATCH: Patch<'static> = Patch {{
            addr: {},
            ucode_patch: &UCODE_PATCH_CONTENT,
            hook_address: {},
            hook_entry: {},
        }};

        {allow_dead}
        const UCODE_PATCH_CONTENT: [UcodePatchEntry; {length}] = [\n{}
        ];
        ",
        addr.expect("No address found")
            .to_string()
            .replace("\"", ""),
        format!("{:?}", hook_address).replace("\"", ""),
        format!("{:?}", hook_entry).replace("\"", ""),
        patch
    );

    std::fs::write(&target, content).expect("Patch file not writable");

    // run rustfmt
    let _ = Command::new("rustfmt")
        .arg(target.as_ref())
        .spawn()
        .expect("rustfmt not found")
        .wait()
        .expect("rustfmt failed");
}
