use error_chain::error_chain;
use regex::{Captures, Replacer};
use std::io::Read;
use std::path::Path;
use std::path::PathBuf;
use std::process::Command;
use std::{env, fs};

error_chain! {
    errors {
        CompilerNotFound {
            description("Compiler not found")
            display("Compiler not found. Path does not exist")
        }
        CompilerInvocationError {
            description("Compiler invocation error")
            display("Compiler invocation error")
        }
        CompilationFailed(exit_code: i32) {
            description("Compiler invocation error")
            display("Compiler invocation error. Exit code: {}", exit_code)
        }
        SourceFileDoesNotExist(path: PathBuf) {
            description("Source file does not exist")
            display("Source file {:?} does not exist", path)
        }
    }

    skip_msg_variant
}

pub struct UcodeCompiler {
    compiler_path: PathBuf,
}

impl UcodeCompiler {
    pub fn new(path: PathBuf) -> Result<UcodeCompiler> {
        if !path.exists()
            || path
                .extension()
                .map(|v| v.to_string_lossy().to_string())
                .unwrap_or("".to_string())
                != "py"
        {
            return Err(ErrorKind::CompilerNotFound.into());
        }

        Ok(UcodeCompiler {
            compiler_path: path,
        })
    }

    pub fn compile(
        &self,
        cpuid: Option<String>,
        input: &PathBuf,
        output: &PathBuf,
        avoid_unknown_256: bool,
    ) -> Result<()> {
        if !input.exists() {
            return Err(ErrorKind::SourceFileDoesNotExist(input.to_owned()).into());
        }

        let mut command = Command::new("python3");

        match self.compiler_path.to_str() {
            None => return Err(ErrorKind::CompilerNotFound.into()),
            Some(path) => command.arg(path),
        };

        if let Some(cpuid) = cpuid {
            command.arg("--cpuid").arg(cpuid);
        }

        command.arg("-i").arg(input).arg("-o").arg(output);

        if avoid_unknown_256 {
            command.arg("--avoid_unk_256");
        }

        let mut cmd = command
            .spawn()
            .map_err(|_| ErrorKind::CompilerInvocationError)?;

        let result = cmd.wait().map_err(|_| ErrorKind::CompilerInvocationError)?;

        if let Some(mut stdout) = cmd.stdout {
            let mut output = String::new();
            stdout
                .read_to_string(&mut output)
                .map_err(|_| ErrorKind::CompilerInvocationError)?;
            println!("{}", output);
        }
        if let Some(mut stderr) = cmd.stderr {
            let mut output = String::new();
            stderr
                .read_to_string(&mut output)
                .map_err(|_| ErrorKind::CompilerInvocationError)?;
            eprintln!("{}", output);
        }

        if result.success() {
            Ok(())
        } else {
            match result.code() {
                Some(code) => Err(ErrorKind::CompilationFailed(code).into()),
                None => Err(ErrorKind::CompilerInvocationError.into()),
            }
        }
    }
}

pub const AUTOGEN: &str = "// AUTOGEN_NOTICE: this file is automatically generated. Do not change stuff. This file will be overriden without further notice.";

pub const AUTOGEN_PREFIX: &str = "// AUTOGEN_NOTICE: ";

pub fn build_script<P: AsRef<Path>, Q: AsRef<Path>>(
    patch_source_folder: P,
    target_rust_folder: Q,
    allow_unused: bool,
) {
    if !target_rust_folder.as_ref().exists() {
        fs::create_dir(&target_rust_folder).expect("Failed to create target directory");
    } else {
        for file in target_rust_folder
            .as_ref()
            .read_dir()
            .expect("Target directory not readable")
        {
            let file = file.expect("Target file not found").path();
            if file
                .extension()
                .map(|v| v.to_string_lossy().to_string())
                .unwrap_or("".to_string())
                .as_str()
                == "rs"
            {
                if std::fs::read_to_string(&file)
                    .expect("Unable to read target file")
                    .starts_with(AUTOGEN_PREFIX)
                {
                    fs::remove_file(file).expect("Unable to remove target file");
                } else {
                    panic!("Target file {file:?} exists but does not contain AUTOGEN_NOTICE");
                }
            }
        }
    }

    let module_path = target_rust_folder.as_ref().with_extension("rs");
    if module_path.exists() {
        // try to check if AUTOGEN_NOTICE
        let content = std::fs::read_to_string(&module_path).expect("Module file not readable");
        if !content.starts_with(AUTOGEN_PREFIX) {
            panic!("The target module file exists but does not contain AUTOGEN_NOTICE");
        }
    }

    let names =
        crate::build_script_convert_folder(patch_source_folder, &target_rust_folder, allow_unused);

    let allow_import = if allow_unused {
        "#[allow(unused_imports)]\n"
    } else {
        ""
    };

    let content = names.iter().fold(String::new(), |acc, name| {
        acc + &format!("pub(crate) mod {name};\n{allow_import}pub use {name}::PATCH as {name};\n")
    });
    std::fs::write(&module_path, format!("{AUTOGEN}\n\n{content}").as_str())
        .unwrap_or_else(|_| panic!("Failed to write {module_path:?}"));

    // run rustfmt
    let _ = Command::new("rustfmt")
        .arg(module_path)
        .spawn()
        .expect("rustfmt not found")
        .wait()
        .expect("rustfmt failed");
}

pub fn build_script_convert_folder<P: AsRef<Path>, Q: AsRef<Path>>(
    patch_source_folder: P,
    target_rust_folder: Q,
    allow_unused: bool,
) -> Vec<String> {
    let current_directory =
        PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("Cargo must include Manifest dir"));

    if !current_directory.exists() {
        panic!("CARGO_MANIFEST_DIR directory does not exist");
    }
    if !patch_source_folder.as_ref().exists() {
        panic!("Source folder does not exist");
    }
    if !target_rust_folder.as_ref().exists() {
        panic!("Target folder does not exist");
    }

    println!(
        "cargo::rerun-if-changed={}",
        patch_source_folder.as_ref().to_string_lossy()
    );
    println!(
        "cargo::rerun-if-changed={}/*",
        patch_source_folder.as_ref().to_string_lossy()
    );

    let ucode_compiler = current_directory
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("CustomProcessingUnit")
        .join("uasm-lib")
        .join("uasm.py");
    println!(
        "cargo::rerun-if-changed={}",
        ucode_compiler.to_string_lossy()
    );

    let compiler = UcodeCompiler::new(ucode_compiler).expect("Ucode compiler not found");

    let mut patch_names = Vec::new();

    for patch in patch_source_folder
        .as_ref()
        .read_dir()
        .expect("Patches directory not readable")
    {
        let patch = patch.expect("Patch not found").path();

        if patch
            .extension()
            .map(|v| v.to_str().unwrap_or(""))
            .unwrap_or("")
            == "u"
        {
            println!("cargo::rerun-if-changed={}", patch.to_string_lossy());
            println!("Compiling: {:?}", patch);

            let target_file = target_rust_folder
                .as_ref()
                .join(patch.file_name().expect("Patch file name not found"));
            patch_names.push(
                target_file
                    .with_extension("")
                    .file_name()
                    .unwrap()
                    .to_string_lossy()
                    .to_string(),
            );

            compiler
                .compile(None, &patch, &target_file.with_extension("h"), true)
                .expect("Compilation failed");
            transform_patch(
                target_file.with_extension("h"),
                target_file.with_extension("rs"),
                allow_unused,
            );
            fs::remove_file(target_file.with_extension("h")).expect("Patch file not removed");
        }
    }

    patch_names
}

fn transform_patch<P: AsRef<Path>, Q: AsRef<Path>>(patch: P, target: Q, allow_unused: bool) {
    // Transform the patch file from C-header to rust

    let content = std::fs::read_to_string(patch).expect("Patch file not readable");

    let mut addr = None;
    let mut hook_address = None;
    let mut hook_entry = None;

    let allow_dead = if allow_unused {
        "#[allow(dead_code)]"
    } else {
        ""
    };

    let mut labels = Vec::default();

    let regex_labels = regex::Regex::new("unsigned long LABEL_([^ ]+) = (0[xX][0-9a-fA-F]+);")
        .expect("regex compile error");
    for capture in regex_labels.captures_iter(&content) {
        let name = capture.get(1).expect("Capture not found").as_str();
        let address = capture.get(2).expect("Capture not found").as_str();

        let public = if name.starts_with("func") || name.ends_with("func") || name.contains("entry") {
            "pub "
        } else {
            ""
        };

        labels.push((name.to_uppercase(), address, public));
    }
    let labels_count = labels.len();
    let labels_const = labels.iter().map(|(label, value, public)| format!("#[allow(dead_code)]\n{public} const LABEL_{label}: UCInstructionAddress = UCInstructionAddress::from_const({value});")).collect::<Vec<String>>().join("\n");
    let labels_array = labels
        .iter()
        .map(|(label, _value, _public)| format!("({label:?}, LABEL_{label}),"))
        .collect::<Vec<String>>()
        .join("\n");

    let regex_variables =
        regex::Regex::new("unsigned long (addr|hook_address|hook_entry) = (0[xX][0-9a-fA-F]+);")
            .expect("regex compile error");

    for capture in regex_variables.captures_iter(&content) {
        let content = capture
            .get(2)
            .expect("Capture not found")
            .as_str()
            .to_string();
        if let Some(variable) = capture.get(1) {
            match variable.as_str() {
                "addr" => addr = Some(content),
                "hook_address" => hook_address = Some(content),
                "hook_entry" => hook_entry = Some(content),
                _ => unreachable!("Unknown variable"),
            }
        }
    }

    let hook_address = hook_address
        .map(|v| format!("Some(UCInstructionAddress::from_const({}))", v))
        .unwrap_or("None".to_string());
    let hook_entry = hook_entry
        .map(|v| format!("Some(MSRAMHookIndex::from_const({}))", v))
        .unwrap_or("None".to_string());

    let regex_array = regex::Regex::new("unsigned long ucode_patch\\[]\\[4] = \\{\n(([^}]*[^;])*)")
        .expect("Regex compile error");

    let patch = regex_array
        .captures_iter(&content)
        .next()
        .expect("No patch block")
        .get(1)
        .expect("No match")
        .as_str();
    let patch = patch.replace("    {", "    [").replace("},\n", "],\n");
    let patch = &patch[0..patch.len() - 4];
    let length = patch.lines().count() / 2;

    let content = format!(
        "{AUTOGEN}

        use data_types::{{UcodePatchEntry, Patch, LabelMapping}};
        #[allow(unused_imports)]
        use data_types::addresses::{{UCInstructionAddress, MSRAMHookIndex}};

        {labels_const}

        const LABELS: [LabelMapping<'static>; {labels_count}] = [{labels_array}];

        {allow_dead}
        pub const PATCH: Patch<'static, 'static, 'static> = Patch {{
            addr: UCInstructionAddress::from_const({}),
            ucode_patch: &UCODE_PATCH_CONTENT,
            hook_address: {},
            hook_index: {},
            labels: &LABELS,
        }};

        {allow_dead}
        const UCODE_PATCH_CONTENT: [UcodePatchEntry; {length}] = [\n{}
        ];
        ",
        addr.expect("No address found")
            .to_string()
            .replace("\"", ""),
        format!("{:?}", hook_address).replace("\"", ""),
        format!("{:?}", hook_entry).replace("\"", ""),
        patch
    );

    std::fs::write(&target, content).expect("Patch file not writable");

    // run rustfmt
    let _ = Command::new("rustfmt")
        .arg(target.as_ref())
        .spawn()
        .expect("rustfmt not found")
        .wait()
        .expect("rustfmt failed");
}

#[derive(Default)]
struct IncludeReplacer {}
impl Replacer for IncludeReplacer {
    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
        let name = caps.get(2).expect("include path not given").as_str();
        let path = PathBuf::from("patches").join(name);
        println!("cargo:rerun-if-changed={}", path.to_string_lossy());
        let content = std::fs::read_to_string(path).expect("read failed");

        dst.push_str(format!("#------------- INCLUDE {name}\n").as_str());
        dst.push_str(&content);
        dst.push_str(format!("\n#------------- END INCLUDE {name}\n").as_str());
    }
}

#[derive(Default)]
struct FuncIncludeReplacer {}
impl Replacer for FuncIncludeReplacer {
    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
        let name = caps.get(1).expect("func name not given").as_str();
        let args = caps.get(2).expect("func args not given").as_str();

        let args_regex = regex::Regex::new(r" *([^,) ]+) *").expect("regex compile error");
        let args = args_regex
            .captures_iter(args)
            .map(|c| c.get(1).expect("arg not found").as_str())
            .collect::<Vec<&str>>();

        let path = PathBuf::from("patches").join(name).with_extension("func");
        println!("cargo:rerun-if-changed={}", path.to_string_lossy());
        let mut content = std::fs::read_to_string(path).expect("read failed");

        let rewrite_regex =
            regex::Regex::new(r"(?m)^# *(ARG\d+) ?: ?(\S+)").expect("regex compile error");
        for cap in rewrite_regex.captures_iter(content.clone().as_str()) {
            let arg = cap.get(1).expect("arg not found").as_str();
            let value = cap.get(2).expect("value not found").as_str();
            content = content.replace(value, arg);
        }

        for (i, arg) in args.iter().enumerate().rev() {
            content = content.replace(format!("ARG{i}").as_str(), arg);
        }

        dst.push_str(format!("#------------- FUNCTION {name}\n").as_str());
        dst.push_str(&content);
        dst.push_str(format!("\n#------------- END FUNCTION {name}\n").as_str());
    }
}

#[derive(Default)]
struct DefineResolveReplacer {
    pub defines: Vec<(String, String)>,
}

impl Replacer for &mut DefineResolveReplacer {
    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
        let name = caps.get(2).expect("define name not given").as_str();
        let value = caps.get(3).expect("define value not given").as_str();

        let all = caps.get(0).expect("capture not found").as_str();

        self.defines.push((name.to_string(), value.to_string()));

        dst.push_str(format!("# def {value}").as_str());
    }
}

pub fn preprocess_scripts<A: AsRef<Path>, B: AsRef<Path>>(src: A, dst: B) {
    let include_regex =
        regex::Regex::new(r"(?m)^ *include( <?([^>]+)>?)?( *#.*)?$").expect("regex compile error");
    let func_include_regex = regex::Regex::new(r"(?m)^ *func *([\S/]+) *\(([^,)]*(, ?[^,)]*)*)\)( *#.*)?$")
        .expect("regex compile error");
    let define_regex = regex::Regex::new(r"(?m)^def(\s+(\S+)\s*:?=\s*([^;\n]+)\s*;)?").expect("regex compile error");

    for file in dst
        .as_ref()
        .read_dir()
        .expect("Target directory not readable")
    {
        let file = file.expect("Target file not found").path();

        if file
            .extension()
            .map(|o| o.to_string_lossy().to_string())
            .unwrap_or("".to_string())
            == "u"
        {
            std::fs::remove_file(file).unwrap()
        }
    }

    for file in src
        .as_ref()
        .read_dir()
        .expect("Source directory not readable")
    {
        let file = file.expect("Target file not found").path();

        println!("cargo:rerun-if-changed={}", file.to_string_lossy());

        if file
            .extension()
            .map(|o| o.to_string_lossy().to_string())
            .unwrap_or("".to_string())
            != "u"
        {
            continue;
        }

        let content = std::fs::read_to_string(&file).expect("read failed");

        let target_content = include_regex
            .replace_all(&content, IncludeReplacer::default())
            .to_string();
        let target_content = func_include_regex
            .replace_all(&target_content, FuncIncludeReplacer::default())
            .to_string();

        let mut define_replacer = DefineResolveReplacer::default();
        let target_content = define_regex.replace_all(&target_content, &mut define_replacer).to_string();

        let defines = define_replacer.defines;
        let target_content = defines.iter().fold(target_content, |acc, (name, value)| {
            acc.replace(name, value)
        });

        let target_file = dst
            .as_ref()
            .join(file.file_name().expect("file name error"));

        std::fs::write(target_file, target_content).expect("write failed");
    }
}
