diff --git a/uasm-lib/uasm.py b/uasm-lib/uasm.py
index 8cb98cf..cfac070 100755
--- a/uasm-lib/uasm.py
+++ b/uasm-lib/uasm.py
@@ -1260,6 +1260,7 @@ def normalize(instruction):
     instruction = re.sub(' ', '', instruction)
     instruction = re.sub('U([a-f0-9]{4})', '0x\g<1>', instruction)
     instruction = re.sub('0x0+', '0x', instruction)
+    instruction = re.sub('SAVEUIP([01])0x[123]', 'SAVEUIP\g<1>,', instruction)
     return instruction
 
 def ldat_gen_base():
@@ -1300,6 +1301,7 @@ def assemble_uop(uop, modifiers, labels, var_to_reg):
     
     src0 = operands.split(',')[0].strip() if len(operands.split(',')) > 0 else ''
     src0 = get_reg(src0)
+    # print("> ", uop)
     if src0 in labels:
         src0_id = labels[src0]
         src0_is_imm = True
@@ -1498,9 +1500,16 @@ def assemble_seqword(partial_seqwords, labels, is_last):
     oooe_sync_ctrls = {"SYNCFULL": 4, "SYNCWAIT": 5, "SYNCMARK": 6, "SYNCWTMRK": 7}
     sync_ctrls = {**lfence_sync_ctrls, **oooe_sync_ctrls}
 
+    # force nop
+    force_nop = False
+    nop_not_applicable = False
+
     for uidx, _seqw in enumerate(partial_seqwords):
         for seqw in _seqw.split(", "):
-            if "GOTO" in seqw:
+            if 'NOP' == seqw:
+                force_nop = True
+
+            elif "GOTO" in seqw:
                 if tetrad_ctrl_uidx != 0x03:
                     print(f'[ERROR] invalid seqws - cannot specify tetrad_ctrl twice: {", ".join(partial_seqwords)}')
                     exit(1)
@@ -1508,6 +1517,7 @@ def assemble_seqword(partial_seqwords, labels, is_last):
                 next_uaddr = labels[next_uaddr] if next_uaddr in labels else int(next_uaddr, 16)
                 tetrad_ctrl_uidx = uidx
                 tetrad_ctrl_next_uaddr = next_uaddr
+                nop_not_applicable = True
             
             elif seqw in uop_ctrls:
                 if uop_ctrl:
@@ -1516,6 +1526,7 @@ def assemble_seqword(partial_seqwords, labels, is_last):
 
                 uop_ctrl_uidx = uidx
                 uop_ctrl = uop_ctrls[seqw]
+                nop_not_applicable = True
 
             elif seqw in sync_ctrls:
                 if sync_ctrl:
@@ -1524,6 +1535,7 @@ def assemble_seqword(partial_seqwords, labels, is_last):
                 
                 sync_ctrl_uidx = uidx
                 sync_ctrl = sync_ctrls[seqw]
+                nop_not_applicable = True
 
             elif seqw == '':
                 pass
@@ -1532,6 +1544,13 @@ def assemble_seqword(partial_seqwords, labels, is_last):
                 print(f'[ERROR] unknown seqws: "{seqw}" in {", ".join(partial_seqwords)}')
                 exit(1)
 
+    if force_nop and nop_not_applicable:
+        print(f'[ERROR] invalid seqws - cannot force NOP and specify any other sequence words.')
+        exit(1)
+    
+    if force_nop:
+        return NOP_SEQWORD
+
     seqw_bin = (sync_ctrl << 25) | (sync_ctrl_uidx << 23) | (tetrad_ctrl_next_uaddr << 8) | (tetrad_ctrl_uidx << 6) | (uop_ctrl << 2) | (uop_ctrl_uidx)
 
     # add both CRCs
@@ -1558,6 +1577,50 @@ def assemble_seqword(partial_seqwords, labels, is_last):
 
     return seqw_bin
 
+def compile_uop(uop_str, labels, var_to_reg):
+    uop = uop_str.split('!')[0].split("SEQW")[0].split('#')[0].strip()
+    modifiers = uop_str.split('!')[1].split("SEQW")[0].split('#')[0].strip() if '!' in uop_str else ''
+
+    seqw = uop_str.split("SEQW")[1].split('#')[0].strip() if 'SEQW' in uop_str else ''
+    # replace labels in seqw
+    for label, l_uaddr in labels.items():
+        seqw = seqw.replace(label, f"0x{l_uaddr:04x}")
+
+    # skip labels and declarations
+    if is_empty(uop) or is_label(uop) or is_decl(uop):
+        return None, None, None
+
+    # deal with raw instructions
+    if uop.startswith('$'):
+        raw_uop = True
+        uop_bin = int(uop[1:], 16)
+    else:
+        raw_uop = False
+        uop_bin = assemble_uop(uop, modifiers, labels, var_to_reg)
+
+    # add both CRCs
+    f_parity = lambda a,b: a^b
+    crc1 = reduce(f_parity, get_even_bits(uop_bin))
+    crc2 = reduce(f_parity, get_odd_bits(uop_bin))
+    uop_bin |= (crc1 << 47)
+    uop_bin |= (crc2 << 46)
+    assert crc(uop_bin) == (0,0)
+
+    uop_nolabels = uop + ((' !' + modifiers) if modifiers else '')
+    for label in labels:
+        uop_nolabels = uop_nolabels.replace(label, f'U{labels[label]:04x}')
+    for var, reg in var_to_reg.items():
+        uop_nolabels = uop_nolabels.replace(var, reg)
+    if not raw_uop and normalize(uop_disassemble(uop_bin, 0)) != normalize(uop_nolabels):
+        print('[ERROR] something went wrong while compiling:')
+        print(f'    input:  {uop_nolabels}')
+        print(f'    output: {hex(uop_bin)}')
+        print(f'    disass:  {uop_disassemble(uop_bin, 0)}')
+        # if opcode not in g_special_opcodes:
+        exit(1)
+
+    return uop_bin, seqw, uop_nolabels
+
 def assemble_ucode(ucode, avoid_unk_256, output):
     triads = [[]]
     seqws = [[]]
@@ -1608,6 +1671,14 @@ def assemble_ucode(ucode, avoid_unk_256, output):
             reg_to_var[reg] = var
             continue
 
+        uop_str_no_comment = uop.strip().split('#')[0].strip()
+        if uop_str_no_comment == "NOPBARRIER" or uop_str_no_comment == "NOPB":
+            if _address & 3 == 0:
+                continue
+            else:
+                _address += 4 - (_address & 3)
+                continue
+
         _address += 1
         if _address & 3 == 3:
             # skip fixed-nop uops slot
@@ -1619,47 +1690,22 @@ def assemble_ucode(ucode, avoid_unk_256, output):
 
     # now assemble
     for uop_str in uops:
-        uop = uop_str.split('!')[0].split("SEQW")[0].split('#')[0].strip()
-        modifiers = uop_str.split('!')[1].split("SEQW")[0].split('#')[0].strip() if '!' in uop_str else ''
+        uop_str_no_comment = uop_str.strip().split('#')[0].strip()
+        if uop_str_no_comment == "NOPBARRIER" or uop_str_no_comment == "NOPB":
+            while len(triads[-1]) < 3 and len(triads[-1]) != 0:
+                uop_bin, seqw, uop_nolabels = compile_uop("NOP", labels, var_to_reg)
+                
+                triads[-1].append(uop_bin)
+                seqws[-1].append(seqw)
+                instructions[-1].append(f"NOPB")
+                
+            continue
 
-        seqw = uop_str.split("SEQW")[1].split('#')[0].strip() if 'SEQW' in uop_str else ''
-        # replace labels in seqw
-        for label, l_uaddr in labels.items():
-            seqw = seqw.replace(label, f"0x{l_uaddr:04x}")
+        uop_bin, seqw, uop_nolabels = compile_uop(uop_str, labels, var_to_reg)
 
-        # skip labels and declarations
-        if is_empty(uop) or is_label(uop) or is_decl(uop):
+        if uop_bin is None:
             continue
 
-        # deal with raw instructions
-        if uop.startswith('$'):
-            raw_uop = True
-            uop_bin = int(uop[1:], 16)
-        else:
-            raw_uop = False
-            uop_bin = assemble_uop(uop, modifiers, labels, var_to_reg)
-
-        # add both CRCs
-        f_parity = lambda a,b: a^b
-        crc1 = reduce(f_parity, get_even_bits(uop_bin))
-        crc2 = reduce(f_parity, get_odd_bits(uop_bin))
-        uop_bin |= (crc1 << 47)
-        uop_bin |= (crc2 << 46)
-        assert crc(uop_bin) == (0,0)
-
-        uop_nolabels = uop + ((' !' + modifiers) if modifiers else '')
-        for label in labels:
-            uop_nolabels = uop_nolabels.replace(label, f'U{labels[label]:04x}')
-        for var, reg in var_to_reg.items():
-            uop_nolabels = uop_nolabels.replace(var, reg)
-        if not raw_uop and normalize(uop_disassemble(uop_bin, 0)) != normalize(uop_nolabels):
-            print('[ERROR] something went wrong while compiling:')
-            print(f'    input:  {uop_nolabels}')
-            print(f'    output: {hex(uop_bin)}')
-            print(f'    disass:  {uop_disassemble(uop_bin, 0)}')
-            # if opcode not in g_special_opcodes:
-            exit(1)
-
         if len(triads[-1]) == 3:
             triads.append([])
             seqws.append([])
@@ -1673,13 +1719,15 @@ def assemble_ucode(ucode, avoid_unk_256, output):
         if output:
             with open(output, mode) as f:
                 print(s, file=f)
-        print(s)
+        # print(s)
     
     tee(f'unsigned long addr = 0x{address:04x};', mode='w')
     if not hook_address is None:
         tee(f'unsigned long hook_address = 0x{hook_address:04x};')
     if not hook_entry is None:
         tee(f'unsigned long hook_entry = 0x{hook_entry:02x};')
+    for k,v in labels.items():
+        tee(f'unsigned long LABEL_{k[1:-1]} = 0x{v:04x};')
     tee('unsigned long ucode_patch[][4] = {')
     for i, (triad, partial_seqwords, instruction) in enumerate(zip(triads, seqws, instructions)):
         is_last = i == len(triads)-1
@@ -1786,7 +1834,7 @@ def print_patches():
 
 cpuid_ = ''
 @click.command()
-@click.option('-c', '--cpuid', type=str, default='0x000506C9', help='the cpuid of the target CPU')
+@click.option('-c', '--cpuid', type=str, default='0x000506CA', help='the cpuid of the target CPU')
 @click.option('-d', '--disasm', is_flag=True)
 @click.option('-s','--seqwords', type=str, default=None)
 @click.option('-u','--uops',type=str,default=None)
