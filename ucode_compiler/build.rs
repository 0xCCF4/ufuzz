use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    generate_opcode_file("src/opcodes.txt", "src/utils/opcodes.rs");
}

fn generate_opcode_file<A: AsRef<Path>, B: AsRef<Path>>(opcodes: A, target_file: B) {
    let opcode_file = fs::read_to_string(&opcodes).expect("Failed to read opcodes file");
    println!(
        "cargo:rerun-if-changed={}",
        opcodes.as_ref().to_string_lossy()
    );

    let mut result = String::new();
    result.push_str(
        "// This file is automatically generated. It will be overwritten without further notice.",
    );
    result.push_str("\n");

    let mut already_found_mnemonics = Vec::new();

    let mut definitions = Vec::new();

    for line in opcode_file.lines() {
        if line.trim().is_empty() {
            continue;
        }

        let split = line.split(':').map(|v| v.trim()).collect::<Vec<&str>>();
        assert!(
            split.len() == 2 || split.len() == 3,
            "{:?} is not a valid opcode line",
            split
        );

        let (opcode, mnemonic, comment) = (split[0], split[1], split.get(2).cloned());
        let opcode = u16::from_str_radix(opcode, 16).expect("Failed to parse opcode");

        let mnemonic_duped = if already_found_mnemonics.contains(&mnemonic) {
            let count = already_found_mnemonics
                .iter()
                .filter(|&&m| m == mnemonic)
                .count();
            format!("{}_{}", mnemonic, count + 1)
        } else {
            mnemonic.to_string()
        };

        already_found_mnemonics.push(mnemonic);

        //result.push_str(&format!("const OPCODE_{}: u16 = 0x{:03x};\n", mnemonic_duped, opcode));
        definitions.push((mnemonic_duped, opcode, comment));
    }

    result.push_str("use num_derive::FromPrimitive;\n");

    result.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, FromPrimitive)]\n");
    result.push_str("#[allow(non_camel_case_types)]\n");
    result.push_str("pub enum Opcodes {\n");
    for (mm, op, comment) in definitions {
        if let Some(comment) = comment {
            result.push_str(format!("/// {}\n", comment).as_str());
        }
        result.push_str(format!("{mm} = 0x{op:03x},\n").as_str());
    }
    result.push_str("}\n");

    fs::write(&target_file, result).expect("Failed to write opcode file");
    let _ = Command::new("rustfmt")
        .arg(target_file.as_ref())
        .spawn()
        .map(|mut c| c.wait());
}
